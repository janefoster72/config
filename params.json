{"name":"Config","body":"## Goals\r\n\r\n* Simple and minimal interface and implementation. No magic.\r\n* A clear and obvious way to do things.\r\n* An API and supporting tools that naturally reduces errors.\r\n* Useful information when things do go wrong.\r\n* Git-native change management for all aspects of the system.\r\n* Branch-based development for ops.\r\n\r\n## Concepts\r\n\r\n* __Node__ A server. A Node has a Blueprint and belongs to a Cluster.\r\n* __Blueprint__ The complete set of Patterns that describe a Node.\r\n* __Cluster__ A collection of Nodes that work together.\r\n* __Pattern__ A reusable concept that makes up a Blueprint or another\r\n  Pattern. All Pattern operations are idempotent.\r\n* __Fact__ A bit of information that's implicit to a Node.\r\n* __Variable__ A part of a Blueprint that may be configured. Variables\r\n  may be set on either the Node or Cluster.\r\n* __Service__ A long running application, generally managed by Upstart.\r\n  A Service may be notified that something it depends on has changed.\r\n  When that happens the Service typically restarts.\r\n* __Hub__ A special node that is used to bootstrap other nodes. This can\r\n  be any node in the system or your development computer.\r\n* __TODO__ is monitoring/alerting a core concept?\r\n\r\n### Patterns\r\n\r\nConfig comes with a set of useful Patterns built in. These Patterns form\r\nthe building blocks for your own higher level Patterns and the\r\nBlueprints that use them.\r\n\r\n* __Directory__ A directory on disk.\r\n* __File__ A file on disk. The contents may come from an ERB template\r\n  or a String.\r\n* __Link__ A symbolic (or hard) link.\r\n* __Package__ Install a 3rd party library via apt.\r\n* __Script__ Any executable code (generally bash).\r\n\r\n## Basic Use\r\n\r\nConfig stores everything in a git repository. And by everything we mean\r\nboth the Patterns and Blueprints that describe how we want a Node to\r\nbehave, and the Nodes themselves. To do this, Config uses two git\r\nrepositories. The first, called the \"project\" repo, stores code and\r\nconfiguration that you write. The second, called the \"data\" repo is\r\nmaintained automatically the nodes. It acts as a database describing the\r\nstate of your system.\r\n\r\nTo initialize  project\r\n\r\n    $ mkdir myproject\r\n    $ cd myproject\r\n    $ git init\r\n    $ config-init-project\r\n\r\nThe project layout\r\n\r\n    patterns\r\n      [topic]/README.md\r\n      [topic]/[pattern].rb\r\n      [topic]/templates/[file].erb\r\n    blueprints\r\n      [blueprint].rb\r\n    clusters\r\n      [cluster].rb\r\n    nodes\r\n      [node_fqn].rb\r\n\r\nTo create a new server, begin by creating a Blueprint\r\n\r\n    $ config-create-blueprint webserver\r\n    $ vim blueprints/webserver.rb\r\n    it \"Configures a server to run example.com\"\r\n\r\n    add Nginx::Service\r\n    add Nginx::Site do |site|\r\n      site.host = \"example.com\"\r\n      site.enabled = true\r\n    end\r\n\r\nThis Blueprint uses two Patterns. Those Patterns might look something like this\r\n\r\n    $ config-create-pattern nginx/service\r\n    $ vim patterns/nginx/service.rb\r\n    class Nginx::Service < Config::Pattern\r\n\r\n      it \"Installs nginx and creates a service to run it\"\r\n\r\n      desc \"The name of the service to run\"\r\n      key :service_name, \"nginx\"\r\n\r\n      def call\r\n        package \"nginx\"\r\n        file \"/etc/nginx/nginx.conf\" do |f|\r\n          f.template = \"nginx.conf\"\r\n        end\r\n        service service_name\r\n        notify service_name\r\n      end\r\n    end\r\n\r\n    $ config-create-pattern nginx/site\r\n    $ vim patterns/nginx/site.rb\r\n    class Nginx::Site < Config::Pattern\r\n\r\n      it \"Installs a website to be hosted via nginx\"\r\n\r\n      desc \"The hostname that the site should respond to\"\r\n      key :host\r\n\r\n      desc \"Whether or not the site should be enabled\"\r\n      attr :enabled, true\r\n\r\n      def call\r\n        file \"/etc/nginx/sites-available/#{host}\" do |f|\r\n          f.template = \"site.erb\"\r\n        end\r\n        if enabled\r\n          link \"/etc/nginx/sites-available/#{host}\" => \"/etc/nginx/sites-enabled/#{host}\"\r\n        end\r\n        notify \"nginx\"\r\n      end\r\n    end\r\n\r\nNext we'll create a Cluster to contain the server. Let's call it\r\n'production'.\r\n\r\n    $ config-create-cluster production\r\n    $ vim clusters/production.rb\r\n    # Nothing to see here yet. In the future we can use this file to\r\n    # configure the production cluster differently than another cluster.\r\n\r\nCheck these files into git and push to your remote repository. You're\r\nnow ready to boot a server.\r\n\r\n    $ config-ec2-create-node --cluster=production --blueprint=webserver\r\n\r\nHere we've specified the two required parameters: The Blueprint used to\r\nconfigure the server, and the Cluster that the resulting Node will\r\nbelong to. We wait for AWS to provision us a server, and once the server\r\nboots it will automatically configure itself and store its information\r\nin the data repo.\r\n\r\n    $ config-update-database\r\n\r\nThe database now contains our new node. Specifically, it contains the\r\nfile `nodes/production-webserver-i9999.json` which contains a wealth of\r\ninformation about the server (provided by Ohai).\r\n\r\n## Testing\r\n\r\nBecause developing and testing against a real server is slow, Config\r\nprovides several tools to help you understand what will happen before\r\nyou get there.\r\n\r\n### Try a Blueprint\r\n\r\nOnce the parts are valid, you might want to get an idea of what the\r\nresult of a Blueprint will be.\r\n\r\n    $ config-try-blueprint webserver production\r\n\r\nThe result of this command is a record of everything that would happen\r\nif a webserver executes within the production clsuter. It might look\r\nsomething like this, showing the hierarchy of patterns used and their\r\nresults.\r\n\r\n    # Nginx::Service\r\n      # Config::Patterns::Package\r\n      Installed nginx\r\n      # Config::Patterns::File\r\n      Created /etc/nginx/nginx.conf\r\n          user www;\r\n          worker_processes 1;\r\n          ...\r\n      Set owner of /etc/nginx/nginx.conf to www\r\n      # Config::Patterns::File\r\n      Created /etc/init.d/nginx.conf\r\n          ...\r\n          exec /etc/nginx/bin/nginx -c /etc/nginx/nginx.conf\r\n          ...\r\n      Set owner of /etc/init.d/nginx.conf to root\r\n      ...\r\n    # Nginx::Site\r\n      # Config::Patterns::File\r\n      Created /etc/nginx/sites-available/example.com\r\n          ...\r\n      # Config::Patterns::Link\r\n      Created /etc/nginx/sites-available/example.com => /etc/nginx/sites-enabled/example.com\r\n    Notify nginx\r\n\r\nYou can also try a blueprint without specifying a cluster. Doing so uses\r\na \"spy\" cluster to collect all of the variables required to execute the\r\nblueprint.\r\n\r\n    $ config-try-blueprint production\r\n\r\n## What is a Blueprint\r\n\r\nA Blueprint uses one or more patterns to describe a node. It may be\r\nconfigured via variables from the current node or the current cluster.\r\nBlueprints are stored in `blueprints/[name].rb`.\r\n\r\n### How a Blueprint is executed\r\n\r\nBlueprint execution occurs in a few steps:\r\n\r\n1. **Accumulate** Recursively traverse all patterns.\r\n1. **Validate** Ensure that all patterns have been defined correctly and\r\n   that all attributes have been set.\r\n1. **Resolve** Detect conflicting Patterns. Mark duplicate patterns to\r\n   execute in *skip* mode.\r\n1. **Destroy** If a previous execution exists, find any patterns that\r\n   executed previously but would not execute now. Mark those patterns\r\n   to execute in *destroy* mode.\r\n1. **Execute** Execute all patterns.\r\n\r\n## What is a Pattern\r\n\r\nA Pattern is a reusable bit of configuration. Patterns are composable,\r\nand so therefore may be of any size and scope. Low level patterns such\r\nas `File` and `Package` are provided by Config. You can use these\r\npatterns to create your own, higher level patterns. Patterns are stored\r\nin `patterns/[topic]/[name].rb`.\r\n\r\nAll patterns inherit from `Config::Pattern`. A trivial example looks\r\nlike this.\r\n\r\n    class LastRunAt < Config::Pattern\r\n      def call\r\n        file \"/etc/config_was_run\" do |f|\r\n          f.content = Time.now.to_s\r\n        end\r\n      end\r\n    end\r\n\r\nThis Pattern simply stores the last time that Config was run at\r\n`/etc/config_was_run`. We defined `call` to use the builtin `File`\r\npattern via the `file` helper. To expose what's going on here, let's\r\nrewrite it without the helper.\r\n\r\n    def call\r\n      add Config::Patterns::File do |f|\r\n        f.path = \"/etc/config_was_run\"\r\n        f.content = Time.now.to_s\r\n      end\r\n    end\r\n\r\nWith this we've exposed an important method in Pattern's API.  `add`\r\ntakes a Pattern class and an optional configuration block. You can use\r\nthe `add` method to accumulate any pattern class. It's also worth noting\r\nhere that the `call` method should never modify the underlying system.\r\nIt *only* describes the actions that will occur should you decide to do\r\nso. This separation is critical to Config's builtin testing tools.\r\n\r\n### Attributes\r\n\r\nTo be useful in more than one situation, a pattern uses variables to\r\nalter its behavior. We call those Attributes and they are another of the\r\nAPIs that `Config::Pattern` exposes. Let's look at what\r\n`Config::Patterns::File` as used above might look like.\r\n\r\n    class Config::Patterns::File < Config::Pattern\r\n\r\n      desc \"The path of the file\"\r\n      key  :path\r\n\r\n      desc \"The contents of the file\"\r\n      attr :content\r\n\r\n      ...\r\n    end\r\n\r\nThe Attributes API has three methods. `desc` describes the purpose of an\r\nattribute, `key` defines an attribute that must be unique for all\r\ninstances of this Pattern, and `attr` defines a simple variable.\r\n\r\nPass a second argument to `attr` or `key` to set a default value.\r\n\r\n    attr :content, \"Hello\"\r\n\r\n**Important** All attributes of a pattern must have a value. If nil is\r\nan acceptable value, you must set that as the default.\r\n\r\n#### Keys\r\n\r\nA pattern's Key attributes describe what it means to be a unique\r\ninstance of a pattern. For example in our `File` example, the `path` is\r\ndefined as Key. By defining `path` as a Key, Config will ensure that we\r\nhave one and only one file at that path.\r\n\r\n#### Uniqueness, Conflict and Equality\r\n\r\nAn instance of a Pattern class is said to be *unique* if the value of its\r\nkeys is different from another. These two files are unique because they\r\nare at different paths.\r\n\r\n    add Config::Patterns::File do |f|\r\n      f.path = \"/tmp/file_1\"\r\n    end\r\n    add Config::Patterns::File do |f|\r\n      f.path = \"/tmp/file_2\"\r\n    end\r\n\r\nOn the other hand, these two files are in *conflict* because they have\r\nidentical keys, but the rest of their attributes are not identical.\r\nConfig will not allow you to execute a set of patterns that are in\r\nconflict.\r\n\r\n    add Config::Patterns::File do |f|\r\n      f.path = \"/tmp/file\"\r\n      f.content = \"hello\"\r\n    end\r\n    add Config::Patterns::File do |f|\r\n      f.path = \"/tmp/file\"\r\n      f.content = \"world\"\r\n    end\r\n\r\nTwo instances of a Pattern are said to be *equal* if all of their\r\nattributes are equal. Config will only execute the first of these\r\npatterns, noting explicitly that the second was skipped.\r\n\r\n    add Config::Patterns::File do |f|\r\n      f.path = \"/tmp/file\"\r\n      f.content = \"hello\"\r\n    end\r\n    add Config::Patterns::File do |f|\r\n      f.path = \"/tmp/file\"\r\n      f.content = \"hello\"\r\n    end\r\n\r\nIt's worth noting that if a Pattern defines no keys, it is always unique\r\namong other instances of that Pattern. Be careful if your Pattern has\r\nthis quality as it may indicate a deeper problem with the design.\r\n\r\n### Describe & Logging\r\n\r\nConfig's logging is one the most important tools to understand what's\r\nhappening on your nodes. The Pattern API allows you to specify a name\r\nfor your pattern via either the `describe` method or the `to_s` method.\r\n`to_s` is used to identify the pattern when it's logged.\r\n\r\n    # The default implementation of #to_s includes the class name\r\n    # and the key attributes.\r\n    # => \"[File path:\\\"/var/log/nginx.log\\\"]\"\r\n\r\n    # Override `describe` to change what's within the square brackets.\r\n    def describe\r\n      \"A file at #{path}\"\r\n    end\r\n    # => \"[A file at /var/log/nginx.log]\"\r\n\r\n    # Override `to_s` to change the full description\r\n    def to_s\r\n      \"<#{path}>\r\n    end\r\n    # => \"</var/log/nginx.log>\"\r\n\r\n### Create & Destroy\r\n\r\nThe Pattern API has two additional methods: `create` and `destroy`.\r\n\r\nDuring the Accumulation phase, Config collects all of the patterns and\r\ndetermines uniqueness. Once the set of patterns is found, each pattern\r\nis executed by calling either its `create` or `destroy` method.\r\n\r\n* `create` Alter the node.\r\n* `destroy` Reverse the alteration.\r\n\r\n*If your Pattern only uses other patterns, there is no need to\r\nimplement `create` or `destroy`.*\r\n\r\nA Pattern is destroyed when it has been removed from the set since the\r\nlast execution. Config tracks the set of Patterns on each execution to\r\ndetermine what has been removed. See Lifecycle for more information.\r\n\r\n## What is a Cluster\r\n\r\nA Cluster is a set of Nodes that work together. The simplest way to use\r\nclusters is to create multiple instances of your application (typically\r\ncalled an 'environment'). Besides acting as a grouping mechanism, a\r\nCluster allows configuration of your blueprints. Cluster definitions are\r\nstored in `clusters/[name].rb`\r\n\r\n    $ config-create-cluster production\r\n    $ vim clusters/production.rb\r\n    configure :web,\r\n      host: \"example.com\",\r\n      enabled: true\r\n\r\nHere we have created a `production` cluster and configured some\r\nvariables dealing with \"web\". When a Blueprint executes within this\r\nCluster, it may access variables to alter its behavior. You may define\r\nas many sets of variables as you'd like. If you execute a pattern the\r\ntries to access a variable that is not defined, Config will throw an\r\nerror.\r\n\r\n    $ vim blueprints/webserver.rb\r\n    add Nginx::Site do |site|\r\n      site.host = cluster.web.host\r\n      site.enabled = cluster.web.enabled\r\n    end\r\n\r\n**Ideas** Another dimension of reuse might be blueprint inheritance. I\r\ncould definitely see it useful to define a \"base\" blueprint from which\r\nothers can inherit. What might that look like?\r\n\r\n    $ blueprints/base.rb\r\n    file \"~/.ssh/authorized_keys\" do |f|\r\n      f.template = \"authorized_keys.erb\"\r\n    end\r\n\r\n    $ blueprints/webserver.rb\r\n    inherit :base\r\n    # Obviously the question of multiple inheritance should be asked\r\n    # here. I default to no for simplicity sake but there doesn't seem\r\n    # to be any real harm.\r\n    add Nginx::Server\r\n\r\n    $ cat clusters/production.rb\r\n    blueprint :base,\r\n      ssh_keys: [\"...\"]\r\n    blueprint :webserver,\r\n      host: \"example.com\"\r\n\r\n### Nodes\r\n\r\nA cluster is only useful once nodes are running within it. Each node has\r\naccess to the configuration of other nodes within its cluster, and\r\n*only* within its cluster. You need not fear creating a staging cluster\r\nwhose configuration points to the production database.\r\n\r\nTo access facts about another node in the cluster, you may perform\r\nsimple queries.\r\n\r\n    node = cluster.find_node(MySQL::Server => { master: true })\r\n    node.facts.public_ip\r\n\r\n## What is a Hub\r\n\r\nA Hub acts as the coordinator for nodes within a cluster. You'll\r\ntypically have one hub, but you could have a different one for each\r\ncluster if desired. A hub only differs from any other checkout of your\r\nproject in a few ways. Most importantly, it is the place where your\r\nsecret keys are stored, so that they may be distributed to new nodes.\r\n\r\nYou may use a different key for each cluster. By default, we'll have\r\none key for everything, called \"default\".\r\n\r\n    echo \"shh\" | config-store-secret [NAME]\r\n\r\nThe project and data git repositories are also passed from the hub to\r\nnodes. By default, Config uses the project's origin to determine the\r\nrepos. If your project repo is `my-project.git` the data repo should be\r\nnamed `my-project-data.git`. To use different repos, specify them in\r\n`hub.rb`.\r\n\r\nIf you want to use the same ssh key for both repos, this configuration\r\nshould suffice.\r\n\r\n    $ vim hub.rb\r\n    project_repo 'git@github.com:rcarver/config-example.git'\r\n    data_repo    'git@github.com:rcarver/config-example-data.git'\r\n\r\nIf you wish to use a different key for each repo (GitHub deploy keys for\r\nexample), this form will allow you to specify the details.\r\n\r\n    project_repo do |p|\r\n      p.repo = 'git@github-project:rcarver/config-example.git'\r\n      p.hostname = 'github.com'\r\n      p.ssh_key = 'project'\r\n    end\r\n    data_repo do |p|\r\n      p.repo = 'git@github-data:rcarver/config-example-data.git'\r\n      p.hostname = 'github.com'\r\n      p.ssh_key = 'data'\r\n    end\r\n\r\nThe resulting `.ssh/config` looks something like this.\r\n\r\n    Host github-project\r\n      User git\r\n      Hostname github.com\r\n      IdentityFile /etc/config/ssh-key-project\r\n    Host github-data\r\n      User git\r\n      Hostname github.com\r\n      IdentityFile /etc/config/ssh-key-data\r\n\r\n### Bootstrap\r\n\r\nTo allow a node to manage itself it must be boostrapped. Bootstrapping\r\ninstalls system requirements, installs the secret and clones the git\r\nrepos. To bootstrap any server, run the bootstrap script (written in\r\nbash) on it. To generate a bootstrap script, identify the cluster,\r\nblueprint and a unique name for the node. We call this name the \"FQN\"\r\n(fully qualified name). Here we bootstrap a new production webserver,\r\ncalled \"1\".\r\n\r\n    config-create-bootstrap production-webserver-1 | ssh IP_ADDRESS \"sudo bash\"\r\n\r\nThat's it. When the script completes the server will have a functional\r\ncopy of the project and will have added itself to the database (the\r\n\"data\" repo). To see information about the new node, ask for it.\r\n\r\n    config-show-node production-webserver-1\r\n\r\nBehind the scenes, Config will sync the data repo and then extract node\r\nfacts and other information. You can see the raw data stored at\r\n`.data/project-data/nodes/production-webserver-1.json`.\r\n\r\n## Advanced Configuration\r\n\r\nFollowing are more advanced ways to use Config. You can probably do a lot\r\nwithout these techniques.\r\n\r\n### Extending a Pattern\r\n\r\nAt times you may need to further extend an existing Pattern. For example, Our\r\n`Nginx::Service` pattern is a high level service. It install Nginx and then\r\nuses Upstart to run it. Say we like this pattern, but need to more carefully\r\ncontrol when the underlying Upstart service starts. Use the `intercept` method\r\nto tap that Upstart service and change its configuration.\r\n\r\n    add Nginx::Service do |nginx|\r\n      nginx.intercept Config::Patterns::Upstart do |upstart|\r\n        upstart.start_on = \"some event\"\r\n      end\r\n    end\r\n\r\n### Branch-based development\r\n\r\nSomething here about a workflow like this:\r\n\r\n* Create a new branch\r\n* Make changes to patterns, etc\r\n* Create nodes. Should they be stored or referenced by a \"branch\"\r\n  pointer in the data repo?\r\n* Merging this to master would be weird, right?\r\n* Should a Cluster indicate the branch(es) that are valid to boot from?\r\n* Is this how one might do development?\r\n\r\n## Reference\r\n\r\nA brief overview of Config's APIs and tools.\r\n\r\n### The Hub API\r\n\r\nDSL for `hub.rb`.\r\n\r\n* `project_repo` Set the git url for the project.\r\n* `data_repo` Set the git url for the project data.\r\n\r\n### The Pattern API\r\n\r\nClass methods DSL.\r\n\r\n* `desc` Describe an attribute.\r\n* `key` Define a key attribute.\r\n* `attr` Define an attribute.\r\n\r\nMethods you may override in your Pattern subclass.\r\n\r\n* `validate` Perform deeper validation of attributes before execution.\r\n* `call` Add other Patterns. Don't perform any operations that alter the\r\n  node, do that in `create`.\r\n* `prepare` Prepare and log data before execution.\r\n* `create` Perform operations that alter the Node.\r\n* `destroy` Perform operations that undo the alteration of the Node.\r\n* `describe` Change the string representation of your Pattern.\r\n* `to_s` Change the full string representation of your Pattern.\r\n\r\nHelpers available during Pattern execution.\r\n\r\n* `validation_errors` An appendable (`<<`) object that accumulates\r\n  issues during `validate`.\r\n* `log` A `Config::Log` object. Write to it with `<<`.\r\n* `add(klass, &block)` Add a sub-pattern. Provide a block to set\r\n  attributes on the instantiated pattern.\r\n* The `Config::Patterns` helpers.\r\n\r\n### The Blueprint API\r\n\r\nThe Blueprint API is a subset of the Pattern API. Blueprints act as a\r\nsingle entrypoint for a set of patterns.\r\n\r\n* `log`\r\n* `add`\r\n* The `Config::Patterns` helpers.\r\n\r\n### Config::Patterns helpers\r\n\r\n`Config::Patterns` contains a number of methods to make using the core\r\npatterns simpler. You may extend this module to add your own helpers.\r\n\r\n* `file(path)` Add a `Config::Patterns::File`. Using this helper\r\n  also provides the `template=` method. Use this method to assign the\r\ntemplate file name, expected to live at\r\n`patterns/[topic]/templates/[file]`.\r\n* `dir(path)` Add a `Config::Patterns::Directory`.\r\n\r\n## Authors\r\n\r\n* Ryan Carver (ryan@ryancarver.com / @rcarver)\r\n\r\n## License\r\n\r\nCopyright 2012 Ryan Carver. Licensed under MIT.\r\n","tagline":"A modern, distributed server configuration tool","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}